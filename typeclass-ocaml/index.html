<!doctype html>
<html lang="en-us">
  <head>
    <title>First steps with Category Theory and OCaml // A fractal spectrum of tales</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.68.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Marcello Seri" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://www.mseri.me/css/main.min.4e2016cf62779480fbe7ba44c261abc7b3a9744838af7268702179daa31e0716.css" />

    
<script type="application/javascript">
var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
var doNotTrack = (dnt == "1" || dnt == "yes");
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-44365202-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="First steps with Category Theory and OCaml"/>
<meta name="twitter:description" content="Introduction Category theory is an abstrac mathematical framework that had a huge influence on pure functional programming design patterns. The abstractions and laws that come bundled with the mathematical concepts allow us to write safer and composable interfaces, very prone to equational reasoning, at the price of a steeper learning curve. If you attempt to write some relatively modern Haskell code, you will inevitably have to deal with Monoids, Functions, Monads, Lenses and whatnot typeclassopedia."/>

    <meta property="og:title" content="First steps with Category Theory and OCaml" />
<meta property="og:description" content="Introduction Category theory is an abstrac mathematical framework that had a huge influence on pure functional programming design patterns. The abstractions and laws that come bundled with the mathematical concepts allow us to write safer and composable interfaces, very prone to equational reasoning, at the price of a steeper learning curve. If you attempt to write some relatively modern Haskell code, you will inevitably have to deal with Monoids, Functions, Monads, Lenses and whatnot typeclassopedia." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.mseri.me/typeclass-ocaml/" />
<meta property="article:published_time" content="2017-06-04T22:00:54+00:00" />
<meta property="article:modified_time" content="2017-06-04T22:00:54+00:00" />


    
  </head>
  <body>
    <header class="app-header">
      <a href="https://www.mseri.me"><img class="app-header-avatar" src="/images/gauss_logo.png" alt="Marcello Seri" /></a>
      <h1>A fractal spectrum of tales</h1>
      <p>Free thoughts of a geeky mathematician</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/mseri" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="https://twitter.com/marcelloseri" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg></a>
        
          <a target="_blank" href="https://academic.mseri.me" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-award">
  <title>award</title>
  <circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">First steps with Category Theory and OCaml</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jun 4, 2017
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          34 min read
        </div><div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
          <a class="tag" href="https://www.mseri.me/tags/ocaml/">ocaml</a><a class="tag" href="https://www.mseri.me/tags/blog/">blog</a><a class="tag" href="https://www.mseri.me/tags/monad/">monad</a><a class="tag" href="https://www.mseri.me/tags/functor/">functor</a><a class="tag" href="https://www.mseri.me/tags/typeclass/">typeclass</a></div></div>
    </header>
    <div class="post-content">
      <h1 id="introduction">Introduction</h1>
<p>Category theory is an abstrac mathematical framework that had a huge influence
on pure functional programming design patterns. The abstractions and laws that
come bundled with the mathematical concepts allow us to write safer and
composable interfaces, very prone to equational reasoning, at the price of a
steeper learning curve. If you attempt to write some relatively modern Haskell
code, you will inevitably have to deal with Monoids, Functions, Monads, Lenses
and whatnot <a href="https://wiki.haskell.org/Typeclassopedia" title="Typeclassopedia">typeclassopedia</a>. Also, if you are using modern OCaml libraries,
you will find fingerprints of these constructs all over the place, even though
there they are less prominent.</p>
<p>These are the notes of a talk, I&rsquo;ve given for our team at Citrix. The aim was to
try to introduce some of those abstract concepts with trivial and less trivial
examples, trying to formalize them using the powerful but verbose syntax of the
OCaml module system. I am relatively new to the OCaml world, and there are
likely some things that can be done better, especially toward the end of the
notes. If you have ideas on fixes and improvements, please let me know in the
comments and I&rsquo;ll try to update and correct the text.</p>
<p>In what follows, I will focus on Monoids, Functors (not to be confused with
OCaml&rsquo;s module functors), Applicatives, Alternatives and, only briefly, Monads
(these will be the
<a href="https://medium.com/@huund/monadic-error-handling-1e2ce66e3810">core of another talk</a>,
that will be followed by a final one on the Free Monad &ndash; I will link the
notes here if they are made public).</p>
<p>There is plenty more to discuss: Semigroups, Categories, Semigroupoids,
F-Algebras (scary, but these are really powerful and useful: <a href="https://www.youtube.com/watch?v=PK4SOaAGVfg" title="F-algebras or: How I Learned to Stop Worrying and Love the Type System">f-algebras-video</a>,
<a href="https://www.schoolofhaskell.com/user/bartosz/understanding-algebras" title="Understanding F-Algebras">f-algebras-understanding</a>), Foldables, Traversables
<a href="https://discuss.ocaml.org/t/notes-from-compose-2017/240/6" title="An example of Traversable">example-traversable-ocaml</a>, &hellip; You can find a good introduction on the whole
Category Theory for Programmers topic at <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/" title="Category Theory for Programmers">bartosz</a>.</p>
<p>It is always interesting to think about counterexamples. I will not have time to
do it here, but you can find a nice account of some of them at
<a href="http://blog.functorial.com/posts/2015-12-06-Counterexamples.html" title="Counterexamples of Type Classes">counterexamples</a>.</p>
<p>At the very end of the talk I will try to show how we can easily implement a
parser combinator using these concepts. This is heavily inspired by <a href="http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf" title="Monadic Parser Combinators">hutton</a>
(that in turns inspired the famous <a href="https://hackage.haskell.org/package/parsec" title="Haskell's parsec">parsec</a> library from Haskell), however our
parser will be an applicative one and not a monadic one. To understand the
differences it is worth reading the paper linked above and compare the parser
there with the one implemented here.</p>
<p>I will try to follow the ocaml conventions writing capitalized modules (e.g.
<code>Monoid</code>) and fully capital signatures (e.g. <code>MONOID</code>). I will also try to
explicitly mention when I am talking about OCaml Module Functors or functors
in the Haskell sense.</p>
<p>I will use haskell&rsquo;s convention for the list: if <code>x</code> is a value, I will
denote <code>xs</code> a list of <code>x</code>s. In the same way, a list of <code>x</code>s is pattern
matched for me as <code>x :: xs</code>.</p>
<p>We could have written the whole code using the &lsquo;desugared&rsquo; version of Haskell&rsquo;s
typeclasses, see <a href="http://okmij.org/ftp/Computation/typeclass.html" title="Demistifying Type Classes">demistifying-type-classes</a>, but I think it would be more
idiomatic to try and use the module system. Also this provides a good way to
explore some modern OCaml features (while waiting for modular implicits to
land).</p>
<p>For a proper implementation of these and more type classes, please have a look
at <a href="https://github.com/IndiscriminateCoding/clarity" title="Clarity">clarity</a>.  For more advanced concepts, like the free monad, a good start is
<a href="http://rgrinberg.com/posts/free-monads-in-the-wild-ocaml" title="Free monads in the wild - OCaml edition">free-monads-in-the-wild</a>.</p>
<p>While writing this talk, a blog post with practically the same ideas has been
posted, <a href="http://blog.shaynefletcher.org/2017/05/more-type-classes-in-ocaml.html" title="More type classes in OCaml">more-typeclasses</a>. Have a look at that, it does a much better job and
provides more context that what I could do in this brief notes. It also
discusses the Traversables that we are largely ignoring for this seminar. The
main difference between the two is that we are not discussing traversables and
instead spend some time on applicatives. Also some examples differ, although I
have tryed to use a signature as close as possible for the final parser
implementation.</p>
<h1 id="why">Why</h1>
<p>Abstract classes are</p>
<ul>
<li>Composable</li>
<li>Reusable</li>
<li>Testable</li>
</ul>
<p>and you can identify them by the signatures of your functions.</p>
<p>Each class, moreover, will provide a series of general helpers and combinators
that will help having consistent apis for different libraries. Finally, being
baked by mathematical laws, these interfaces are more easily testable. You need
only to test a minimal subset of the functions to ensure that the whole api is
correct.</p>
<p>As a brief example, you probably have already used <code>map</code> or <code>bind</code> over many
different types, e.g. <code>option</code>, <code>resutl</code> or <code>list</code>.</p>
<h1 id="helpers">Helpers</h1>
<p>We will need some preliminary helpers (I will use the same syntax as <a href="https://github.com/IndiscriminateCoding/clarity" title="Clarity">clarity</a>
for those):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> id x <span style="color:#f92672">=</span> x   <span style="color:#75715e">(* look at [clarity], they use a neat compiler trick that we are not using here *)</span>
<span style="color:#66d9ef">let</span> const x <span style="color:#f92672">_</span> <span style="color:#f92672">=</span> x
<span style="color:#66d9ef">let</span> flip f x y <span style="color:#f92672">=</span> f y x
<span style="color:#66d9ef">let</span> compose f g x <span style="color:#f92672">=</span> f <span style="color:#f92672">(</span>g x<span style="color:#f92672">)</span>
<span style="color:#66d9ef">let</span> <span style="color:#f92672">(&lt;.&gt;)</span> f g <span style="color:#f92672">=</span> <span style="color:#66d9ef">fun</span> x <span style="color:#f92672">-&gt;</span> f <span style="color:#f92672">(</span>g x<span style="color:#f92672">)</span>   <span style="color:#75715e">(* &lt;- compose *)</span>
<span style="color:#66d9ef">let</span> <span style="color:#f92672">(&gt;.&gt;)</span> g f <span style="color:#f92672">=</span> <span style="color:#66d9ef">fun</span> x <span style="color:#f92672">-&gt;</span> f <span style="color:#f92672">(</span>g x<span style="color:#f92672">)</span>   <span style="color:#75715e">(* first apply [g] then [f] but writing them the other way around *)</span>
<span style="color:#66d9ef">let</span> cons x xs <span style="color:#f92672">=</span> x <span style="color:#f92672">::</span> xs
</code></pre></div><h1 id="monoids">Monoids</h1>
<p>Let&rsquo;s start with the the complicated (sounding) mathematical definition. A
monoid is an algebraic structure closed under an associative operation (often
denoted <code>mappend</code>) and with a neutral element (often denoted <code>mempty</code>).</p>
<p>For example, integer numbers with the addition or with the multiplication
operators form a <code>Monoid</code>. Integer numbers with the division operator do not
(this is because you cannot divide by <code>0</code>).</p>
<p>This can be specified in OCaml with the following module signature:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MONOID</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">sig</span>
  <span style="color:#75715e">(** Monoid *)</span>
  <span style="color:#66d9ef">type</span> t

  <span style="color:#75715e">(** Neutral element *)</span>
  <span style="color:#75715e">(* without this we have a semigroup... *)</span>
  <span style="color:#66d9ef">val</span> mempty <span style="color:#f92672">:</span> t

  <span style="color:#75715e">(** Associative operation *)</span>
  <span style="color:#66d9ef">val</span> mappend<span style="color:#f92672">:</span> t <span style="color:#f92672">-&gt;</span> t <span style="color:#f92672">-&gt;</span> t
<span style="color:#66d9ef">end</span>
</code></pre></div><p>In order to create a <code>MONOID</code>, we need to provide an implementation of the
<code>mempty</code> and <code>mappend</code> functions (as well as the <code>type</code>).  We can implement the
monoid modules for integer numbers with sum and product as</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Sum</span><span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">MONOID</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">int</span>
  <span style="color:#66d9ef">let</span> mempty  <span style="color:#f92672">=</span> 0
  <span style="color:#66d9ef">let</span> mappend <span style="color:#f92672">=</span> <span style="color:#f92672">(+)</span>
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Prod</span><span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">MONOID</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">int</span>
  <span style="color:#66d9ef">let</span> mempty  <span style="color:#f92672">=</span> 1
  <span style="color:#66d9ef">let</span> mappend <span style="color:#f92672">=</span> <span style="color:#f92672">(</span> <span style="color:#f92672">*</span> <span style="color:#f92672">)</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>NOTE: here we see a first difference with haskell, where polymorphism
allows multiple coexisting definitions of <code>mempty</code> and <code>mappend</code> that
do not need to be encapsulated in a module namespace.</p>
<p>These are true monoids if we make sure that</p>
<pre><code>(* closed: however you choose x, y, z with type t below ... *)
(* neutral element *)
mappend mempty x        = x
mappend x mempty        = x
(* associative *)
mappend x (mappend y z) = mappend (mappend x y) z
</code></pre><p>Note that we cannot enforce these laws with the type system. We need to make
sure that they hold when we are writing the implementation. We can use OCaml
functors (kind of parametrised modules) to add a simple test module for (almost)
any <code>MONOID</code>!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#75715e">(* This is an OCaml functor -- look at its signature on the repl *)</span>
<span style="color:#66d9ef">module</span> <span style="color:#a6e22e">TestMonoid</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">M</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">MONOID</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">M</span>

  <span style="color:#66d9ef">let</span> test_neutral_element x <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">assert</span> <span style="color:#f92672">(</span>mappend mempty x <span style="color:#f92672">=</span> x<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">assert</span> <span style="color:#f92672">(</span>mappend x mempty <span style="color:#f92672">=</span> x<span style="color:#f92672">)</span>

  <span style="color:#66d9ef">let</span> test_assoc x y z <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">assert</span> <span style="color:#f92672">(</span>
      mappend x <span style="color:#f92672">(</span>mappend y z<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> mappend <span style="color:#f92672">(</span>mappend x y<span style="color:#f92672">)</span> z
    <span style="color:#f92672">)</span>

<span style="color:#66d9ef">end</span>
</code></pre></div><p>It is crucial to make sure that these laws are satisfied by your modules,
violating them leads often to code that is difficult to reason about and
refactor.</p>
<p><strong>Exercise</strong>:</p>
<ul>
<li>
<p>run the tests for the monoids defined above</p>
</li>
<li>
<p>check what happens if in the declarations above you replace
<code>MONOID with type t = int</code> with <code>MONOID</code> or <code>MONOID with type t := int</code>.</p>
</li>
</ul>
<p>I mentioned that these patterns allow us to define general common helpers.
Indeed, in all cases we can easily see that the <code>mappend</code> function allows us to
synthesize a list of values into one, e.g.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> example1 () <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> xs <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>1<span style="color:#f92672">;</span> 2<span style="color:#f92672">;</span> 3<span style="color:#f92672">;</span> 4<span style="color:#f92672">;</span> 5<span style="color:#f92672">;</span> 6<span style="color:#f92672">]</span> <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> sum <span style="color:#f92672">=</span>
    List.fold_left Sum.mappend Sum.mempty
  <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> prod <span style="color:#f92672">=</span>
    List.fold_left Prod.mappend Prod.mempty
  <span style="color:#66d9ef">in</span>
  Printf.printf <span style="color:#e6db74">&#34;sum:%d prod:%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">(</span>sum xs<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>prod xs<span style="color:#f92672">)</span>
</code></pre></div><p>In the example above there is clearly a pattern that can be generalised. In
fact, monoids usually come bundled with the following helpers.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Monoid_Utils</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">M</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">MONOID</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#75715e">(** Generic Monoid helpers.
</span><span style="color:#75715e">   * These should really be part of the Monoid module itself *)</span>
  <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">M</span>

  <span style="color:#75715e">(** A convenient shorthand for mappend *)</span>
  <span style="color:#66d9ef">let</span> <span style="color:#f92672">(&lt;+&gt;)</span> x y <span style="color:#f92672">=</span> mappend x y

  <span style="color:#75715e">(** Any monoid can be concatenated *)</span>
  <span style="color:#75715e">(* This is more general and works for any foldable ... *)</span>
  <span style="color:#66d9ef">let</span> concat xs <span style="color:#f92672">=</span> List.fold_left <span style="color:#f92672">(&lt;+&gt;)</span> mempty xs
<span style="color:#66d9ef">end</span>
</code></pre></div><p>Another common simple example of monoid, that does not involve numbers, is the
string:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">StringM</span><span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">MONOID</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">string</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">string</span>
  <span style="color:#66d9ef">let</span> mempty <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
  <span style="color:#66d9ef">let</span> mappend s1 s2 <span style="color:#f92672">=</span> s1<span style="color:#f92672">^</span>s2
<span style="color:#66d9ef">end</span>
</code></pre></div><p>Let&rsquo;s try one more!</p>
<pre><code>(* Broken example... *)
module ListM: (MONOID with type t = 'a list) = struct
  type t = 'a list
  let mempty  = []
  let mappend = (@)
end
</code></pre><p>Unfortunately this will not work, but we can workaround the problem using an
intermediate dummy module (I will never thank enough <a href="http://rgrinberg.com/posts/free-monads-in-the-wild-ocaml" title="Free monads in the wild - OCaml edition">free-monads-in-the-wild</a>
for this).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">GENERIC_TYPE_WORKAROUND</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">sig</span> <span style="color:#66d9ef">type</span> t <span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">module</span> <span style="color:#a6e22e">ListM</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">T</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">GENERIC_TYPE_WORKAROUND</span><span style="color:#f92672">):</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">MONOID</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> T.t <span style="color:#66d9ef">list</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> T.t <span style="color:#66d9ef">list</span>
  <span style="color:#66d9ef">let</span> mempty  <span style="color:#f92672">=</span> []
  <span style="color:#66d9ef">let</span> mappend <span style="color:#f92672">=</span> <span style="color:#f92672">(@)</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>Using this is, unfortunately, a bit verbose:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> example2 () <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> xs <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>1<span style="color:#f92672">;</span> 2<span style="color:#f92672">;</span> 3<span style="color:#f92672">;</span> 4<span style="color:#f92672">;</span> 5<span style="color:#f92672">;</span> 6<span style="color:#f92672">]</span> <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">MSum</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Monoid_Utils</span><span style="color:#f92672">(</span><span style="color:#a6e22e">Sum</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">MProd</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Monoid_Utils</span><span style="color:#f92672">(</span><span style="color:#a6e22e">Prod</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
  Printf.printf <span style="color:#e6db74">&#34;sum:%d prod:%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">(</span>MSum.concat xs<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>MProd.concat xs<span style="color:#f92672">);</span>

<span style="color:#75715e">(* Note how we need to label the type to make it polymorphic *)</span>
<span style="color:#66d9ef">let</span> example3 () <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> xs <span style="color:#f92672">=</span> <span style="color:#f92672">[[</span>1<span style="color:#f92672">;</span>2<span style="color:#f92672">;</span>3<span style="color:#f92672">];[</span>1<span style="color:#f92672">;</span>2<span style="color:#f92672">;</span>3<span style="color:#f92672">];[</span>1<span style="color:#f92672">;</span>2<span style="color:#f92672">;</span>3<span style="color:#f92672">]]</span> <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> concat <span style="color:#f92672">(</span><span style="color:#66d9ef">type</span> a<span style="color:#f92672">)</span> xs <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">ListM</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ListM</span><span style="color:#f92672">(</span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> a <span style="color:#66d9ef">end</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">ListU</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Monoid_Utils</span><span style="color:#f92672">(</span><span style="color:#a6e22e">ListM</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">ListU</span> <span style="color:#66d9ef">in</span>
    ListU.concat xs
  <span style="color:#66d9ef">in</span>
  concat xs
</code></pre></div><p>Two other interesting monoids are <code>Any</code> and <code>All</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">All</span><span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">MONOID</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">bool</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">bool</span>
  <span style="color:#66d9ef">let</span> mempty  <span style="color:#f92672">=</span> true
  <span style="color:#66d9ef">let</span> mappend <span style="color:#f92672">=</span> <span style="color:#f92672">(&amp;&amp;)</span>
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Any</span><span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">MONOID</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">bool</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">bool</span>
  <span style="color:#66d9ef">let</span> mempty  <span style="color:#f92672">=</span> false
  <span style="color:#66d9ef">let</span> mappend <span style="color:#f92672">=</span> <span style="color:#f92672">(||)</span>
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">let</span> example4 () <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> xs   <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>true<span style="color:#f92672">;</span> false<span style="color:#f92672">;</span> false<span style="color:#f92672">;</span> true<span style="color:#f92672">]</span> <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> xs&#39;  <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>true<span style="color:#f92672">;</span> true<span style="color:#f92672">]</span> <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> xs&#39;&#39; <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>false<span style="color:#f92672">;</span> false<span style="color:#f92672">]</span> <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">AllU</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Monoid_Utils</span><span style="color:#f92672">(</span><span style="color:#a6e22e">All</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">AnyU</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Monoid_Utils</span><span style="color:#f92672">(</span><span style="color:#a6e22e">Any</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
  Printf.printf <span style="color:#e6db74">&#34;all: %b %b %b</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">(</span>AllU.concat xs<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>AllU.concat xs&#39;<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>AllU.concat xs&#39;&#39;<span style="color:#f92672">);</span>
  Printf.printf <span style="color:#e6db74">&#34;any: %b %b %b&#34;</span> <span style="color:#f92672">(</span>AnyU.concat xs<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>AnyU.concat xs&#39;<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>AnyU.concat xs&#39;&#39;<span style="color:#f92672">)</span>
</code></pre></div><h1 id="functors">Functors</h1>
<p>Mathematically functors are a bit more complicated than monoids: they are
structure-preserving maps between categories. If monoids represent the things
that can be <em>synthesised</em> (<code>mappend</code>ed), functors represent the things that can
be mapped (literally <code>fmap</code>ped) over. Quoting <a href="https://wiki.haskell.org/Typeclassopedia" title="Typeclassopedia">typeclassopedia</a>:</p>
<blockquote>
<p>There are two fundamental ways to think about <code>fmap</code>. The first has already
been mentioned: it takes two parameters, a function and a container, and applies
the function &ldquo;inside&rdquo; the container, producing a new container. Alternately, we
can think of <code>fmap</code> as applying a function to a value in a context (without
altering the context).</p>
</blockquote>
<p>This can be specified in OCaml with the following module type:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FUNCTOR</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">sig</span>
  <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t
  <span style="color:#66d9ef">val</span> fmap<span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t
<span style="color:#66d9ef">end</span>
</code></pre></div><p>In this case we do not need workarounds to create a module implementing the
<code>FUNCTOR</code> signature for lists:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">ListF</span><span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">FUNCTOR</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#66d9ef">list</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t  <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#66d9ef">list</span>
  <span style="color:#66d9ef">let</span> fmap f <span style="color:#f92672">=</span> List.map f
<span style="color:#66d9ef">end</span>
</code></pre></div><p>As for monoids, functors need to satisfy some laws.  We can translate the
structure-preserving property from the mathematical defitinion into the
following (if you know what a <em>morphism</em> is, this should look familiar)</p>
<pre><code>  (* we map the identity into itself *)
  fmap id = id

  (* mapping a composition of functions is
   * equivalent to composing the mapped functions *)
  fmap (f &lt;.&gt; g)  = fmap f &lt;.&gt; fmap g
</code></pre><p>This is a way to say that our <code>fmap</code> cannot change the &ldquo;shape&rdquo; of the mapped
values. We can translate these into a test module, as we did for the monoids.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">TestFunctor</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">F</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">FUNCTOR</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">F</span>

  <span style="color:#66d9ef">let</span> test_id x <span style="color:#f92672">=</span> <span style="color:#66d9ef">assert</span> <span style="color:#f92672">(</span>fmap id x <span style="color:#f92672">=</span> x<span style="color:#f92672">)</span>

  <span style="color:#66d9ef">let</span> test_compose f g x <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">assert</span> <span style="color:#f92672">(</span>
      fmap <span style="color:#f92672">(</span>f <span style="color:#f92672">&lt;.&gt;</span> g<span style="color:#f92672">)</span> x <span style="color:#f92672">=</span> fmap f <span style="color:#f92672">(</span>fmap g x<span style="color:#f92672">)</span>
    <span style="color:#f92672">)</span>

<span style="color:#66d9ef">end</span>
</code></pre></div><p>Many commonly used types are in fact functor instancess. A few examples are the
following.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#75715e">(* optional values *)</span>
<span style="color:#66d9ef">module</span> <span style="color:#a6e22e">OptionF</span><span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">FUNCTOR</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>a option<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>a option
  <span style="color:#66d9ef">let</span> fmap f <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Some</span> x  <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Some</span> <span style="color:#f92672">(</span>f x<span style="color:#f92672">)</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">None</span>    <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">None</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#75715e">(* result values *)</span>
<span style="color:#66d9ef">module</span> <span style="color:#a6e22e">ResultF</span><span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">FUNCTOR</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> <span style="color:#66d9ef">string</span><span style="color:#f92672">)</span> result<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> <span style="color:#66d9ef">string</span><span style="color:#f92672">)</span> result
  <span style="color:#66d9ef">let</span> fmap f <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Ok</span> x <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Ok</span> <span style="color:#f92672">(</span>f x<span style="color:#f92672">)</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Error</span> <span style="color:#f92672">_</span> <span style="color:#66d9ef">as</span> err <span style="color:#f92672">-&gt;</span> err
<span style="color:#66d9ef">end</span>

<span style="color:#75715e">(* This is only for recent (4.03+) compilers or otherwise it depends
</span><span style="color:#75715e"> * on the result library. The rresult library already provides the
</span><span style="color:#75715e"> * functor (and monad) implementation for it. *)</span>
</code></pre></div><p>As it happened with monoids, functors often come with their generic
helpers as well <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor.html" title="Data.Functor on Hackage">hackage-data.functor</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Functor_Utils</span><span style="color:#f92672">(</span><span style="color:#a6e22e">F</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">FUNCTOR</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#75715e">(** Generic Functor helpers.
</span><span style="color:#75715e">   *  This should be part of the Functor module itself... *)</span>
  <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">F</span>

  <span style="color:#75715e">(** A convenient shorthand for fmap *)</span>
  <span style="color:#66d9ef">let</span> <span style="color:#f92672">(&lt;$&gt;)</span> f x <span style="color:#f92672">=</span> fmap f x

  <span style="color:#75715e">(** Replace all locations in the input with the same value *)</span>
  <span style="color:#66d9ef">let</span> <span style="color:#f92672">(&lt;$)</span> r x <span style="color:#f92672">=</span> fmap <span style="color:#f92672">(</span>const r<span style="color:#f92672">)</span> x
  <span style="color:#75715e">(** Flipped version of &lt;$ *)</span>
  <span style="color:#66d9ef">let</span> <span style="color:#f92672">($&gt;)</span> r x <span style="color:#f92672">=</span> flip <span style="color:#f92672">(&lt;$)</span> r x

  <span style="color:#75715e">(** [void] discards or ignores the result of evaluation *)</span>
  <span style="color:#66d9ef">let</span> void f x <span style="color:#f92672">=</span> fmap <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> x <span style="color:#f92672">-&gt;</span> ignore<span style="color:#f92672">(</span>f x<span style="color:#f92672">))</span> x
<span style="color:#66d9ef">end</span>
</code></pre></div><h2 id="applicative-functors">Applicative Functors</h2>
<p>Applicative functors are a special class of functors carrying some more
structure. Again quoting <a href="https://wiki.haskell.org/Typeclassopedia" title="Typeclassopedia">typeclassopedia</a>:</p>
<blockquote>
<p>The title of their classic paper, <a href="http://www.soi.city.ac.uk/~ross/papers/Applicative.html" title="Applicative Programming with Effects">applicative-programming-with-effects</a>,
gives a hint at the intended intuition behind the <code>Applicative</code> type class. It
encapsulates certain sorts of “effectful” computations in a functionally pure
way, and encourages an “applicative” programming style.</p>
</blockquote>
<p>A minimal implementation is simple, but requires some level of care. The
following comes from <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Applicative.html" title="Control.Applicative on Hackage">hackage-control.applicative</a>.</p>
<blockquote>
<p>An <code>applicative functor</code> is a <code>functor</code> with application, providing operations
to embed effect free expressions (<code>pure</code>), and to apply functions that are in a
context to values already in the context (<code>ap</code>, or the equivalent infix <code>&lt;*&gt;</code>).</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">APPLICATIVE</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">sig</span>
  <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t

  <span style="color:#75715e">(* This includes the signature of FUNCTOR,
</span><span style="color:#75715e">   * rewriting the types to make them match *)</span>
  <span style="color:#66d9ef">include</span> <span style="color:#a6e22e">FUNCTOR</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">:=</span> <span style="color:#66d9ef">&#39;</span>a t

  <span style="color:#75715e">(** Lift a value *)</span>
  <span style="color:#66d9ef">val</span> pure<span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t
  <span style="color:#75715e">(** Sequential application *)</span>
  <span style="color:#66d9ef">val</span> ap<span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t

  <span style="color:#75715e">(* Note that if you still have to define the functor,
</span><span style="color:#75715e">   * you can define `fmap` from the above functions as
</span><span style="color:#75715e">   * `let fmap f x = pure f &lt;*&gt; x` *)</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>Now it should be expectable that there will be plenty of generic helper
functions coming with applicatives as well. This is in fact the case, even more
than for the previous structures.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Applicative_Utils</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">A</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">APPLICATIVE</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#75715e">(** Generic Functor helpers.
</span><span style="color:#75715e">   * This should really be part of the Applcative module itself *)</span>

  <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">A</span>
  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">FunU</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Functor_Utils</span><span style="color:#f92672">(</span><span style="color:#a6e22e">A</span><span style="color:#f92672">)</span>
  <span style="color:#66d9ef">include</span> <span style="color:#a6e22e">FunU</span>

  <span style="color:#75715e">(** A convenient infix for ap -- called apply*)</span>
  <span style="color:#66d9ef">let</span> <span style="color:#f92672">(&lt;*&gt;)</span> f <span style="color:#f92672">=</span> ap f

  <span style="color:#75715e">(* Below, we denote `actions` the elements of the applicative typeclass *)</span>

  <span style="color:#75715e">(** Lift a function to actions. This function may be used as a value
</span><span style="color:#75715e">   *  for fmap in a Functor instance. *)</span>
  <span style="color:#66d9ef">let</span> liftA f x <span style="color:#f92672">=</span> f <span style="color:#f92672">&lt;$&gt;</span> x
  <span style="color:#75715e">(** Lift a binary function to actions. *)</span>
  <span style="color:#66d9ef">let</span> liftA2 f x y  <span style="color:#f92672">=</span> f <span style="color:#f92672">&lt;$&gt;</span> x <span style="color:#f92672">&lt;*&gt;</span> y
  <span style="color:#75715e">(** Lift a ternary function to actions. *)</span>
  <span style="color:#66d9ef">let</span> liftA3 f x y z <span style="color:#f92672">=</span> f <span style="color:#f92672">&lt;$&gt;</span> x <span style="color:#f92672">&lt;*&gt;</span> y <span style="color:#f92672">&lt;*&gt;</span> z

  <span style="color:#75715e">(** Sequence actions, discarding the value of the second argument. *)</span>
  <span style="color:#66d9ef">let</span> <span style="color:#f92672">(</span> <span style="color:#f92672">&lt;*</span> <span style="color:#f92672">)</span> r x <span style="color:#f92672">=</span> const <span style="color:#f92672">&lt;$&gt;</span> r <span style="color:#f92672">&lt;*&gt;</span> x
  <span style="color:#75715e">(** Sequence actions, discarding the value of the first argument. *)</span>
  <span style="color:#66d9ef">let</span> <span style="color:#f92672">(</span> <span style="color:#f92672">*&gt;</span> <span style="color:#f92672">)</span> r x <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> <span style="color:#f92672">_</span> y <span style="color:#f92672">-&gt;</span> y<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;$&gt;</span> r <span style="color:#f92672">&lt;*&gt;</span> x     <span style="color:#75715e">(* == flip ( &lt;* ) *)</span>

  <span style="color:#75715e">(* These should be part of foldable or traversable, and in turn
</span><span style="color:#75715e">   * they end up with applicatives *)</span>

  <span style="color:#75715e">(** Evaluate each action in the structure from left to right, and
</span><span style="color:#75715e">   * and collect the results. *)</span>
  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> sequenceA <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>
    <span style="color:#f92672">|</span> [] <span style="color:#f92672">-&gt;</span> pure []
    <span style="color:#f92672">|</span> x <span style="color:#f92672">::</span> xs <span style="color:#f92672">-&gt;</span> List.cons <span style="color:#f92672">&lt;$&gt;</span> x <span style="color:#f92672">&lt;*&gt;</span> sequenceA xs

  <span style="color:#75715e">(** Evaluate each action in the structure from left to right, and
</span><span style="color:#75715e">   *  ignore the results *)</span>
  <span style="color:#66d9ef">let</span> sequenceA_ xs <span style="color:#f92672">=</span> List.fold_right <span style="color:#f92672">(</span> <span style="color:#f92672">*&gt;</span> <span style="color:#f92672">)</span> xs <span style="color:#f92672">(</span>pure ()<span style="color:#f92672">)</span>

  <span style="color:#75715e">(** Map each element of a structure to an action, evaluate these actions
</span><span style="color:#75715e">   *  from left to right, and collect the results. *)</span>
  <span style="color:#66d9ef">let</span> traverseA f <span style="color:#f92672">=</span>  <span style="color:#f92672">(</span>List.map f<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;.&gt;</span> sequenceA

  <span style="color:#75715e">(** Map each element of a structure to an action, evaluate these
</span><span style="color:#75715e">   *  actions from left to right, and ignore the results. *)</span>
  <span style="color:#66d9ef">let</span> traverseA_ f xs <span style="color:#f92672">=</span> List.fold_right <span style="color:#f92672">((</span> <span style="color:#f92672">*&gt;</span> <span style="color:#f92672">)</span> <span style="color:#f92672">&lt;.&gt;</span> f<span style="color:#f92672">)</span> xs <span style="color:#f92672">(</span>pure ()<span style="color:#f92672">)</span>

  <span style="color:#75715e">(** `forA` is &#39;traverse&#39; with its arguments flipped. *)</span>
  <span style="color:#66d9ef">let</span> forA xs <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>flip traverseA<span style="color:#f92672">)</span> xs
<span style="color:#66d9ef">end</span>
</code></pre></div><p>The <code>liftAN</code> functions are very convenient to <em>lift</em> a regular function of <code>N</code>
arguments into a function operating on <code>N</code> applicative values.</p>
<p>A complete definition must satisfy the following laws (haskell syntax):</p>
<ul>
<li>
<p><em>identity law</em>: <code>pure id &lt;*&gt; v = v</code></p>
</li>
<li>
<p><em>homomorphism</em>: <code>pure f &lt;*&gt; pure x = pure (f x)</code> (<a href="https://wiki.haskell.org/Typeclassopedia" title="Typeclassopedia">typeclassopedia</a> says:
applying a non-effectful function to a non-effectful argument in an effectful
context is the same as just applying the function to the argument and then
injecting the result into the context with <code>pure</code>)</p>
</li>
<li>
<p><em>interchange</em>:  <code>u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</code> (<a href="https://wiki.haskell.org/Typeclassopedia" title="Typeclassopedia">typeclassopedia</a> says:
when evaluating the application of an effectful function to a pure argument, the
order in which we evaluate the function and its argument doesn&rsquo;t matter)</p>
</li>
<li>
<p><em>composition</em>: <code>pure (&lt;.&gt;) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code></p>
</li>
</ul>
<p>These may again be turned into a generic testing module:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">TestApplicative</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">A</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">APPLICATIVE</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">A</span>
  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">ApplU</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Applicative_Utils</span><span style="color:#f92672">(</span><span style="color:#a6e22e">A</span><span style="color:#f92672">)</span>
  <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">ApplU</span>

  <span style="color:#66d9ef">let</span> test_id x <span style="color:#f92672">=</span> <span style="color:#66d9ef">assert</span> <span style="color:#f92672">(</span>
    <span style="color:#f92672">(</span>pure id <span style="color:#f92672">&lt;*&gt;</span> x<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> x
  <span style="color:#f92672">)</span>

  <span style="color:#66d9ef">let</span> test_homomorphism f x <span style="color:#f92672">=</span> <span style="color:#66d9ef">assert</span> <span style="color:#f92672">(</span>
    pure f <span style="color:#f92672">&lt;*&gt;</span> pure x <span style="color:#f92672">=</span> pure <span style="color:#f92672">(</span>f x<span style="color:#f92672">)</span>
  <span style="color:#f92672">)</span>

  <span style="color:#66d9ef">let</span> test_interchange u y <span style="color:#f92672">=</span> <span style="color:#66d9ef">assert</span> <span style="color:#f92672">(</span>
    <span style="color:#f92672">(</span>u <span style="color:#f92672">&lt;*&gt;</span> pure y<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>pure <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> f <span style="color:#f92672">-&gt;</span> f y<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;*&gt;</span> u<span style="color:#f92672">)</span>
  <span style="color:#f92672">)</span>

  <span style="color:#66d9ef">let</span> test_composition u v w <span style="color:#f92672">=</span> <span style="color:#66d9ef">assert</span> <span style="color:#f92672">(</span>
    <span style="color:#f92672">(</span>pure compose <span style="color:#f92672">&lt;*&gt;</span> u <span style="color:#f92672">&lt;*&gt;</span> v <span style="color:#f92672">&lt;*&gt;</span> w<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>u <span style="color:#f92672">&lt;*&gt;</span> <span style="color:#f92672">(</span>v <span style="color:#f92672">&lt;*&gt;</span> w<span style="color:#f92672">))</span>
  <span style="color:#f92672">)</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>This can be used to validate some instances of this pattern. We will see some of
its limitations soon&hellip;</p>
<p>Note that as a consequence of these laws, the functor instance for <code>f</code> will
satisfy</p>
<pre><code>fmap f x = pure f &lt;*&gt; x
</code></pre><p>Let&rsquo;s see how this much stuff can be rewritten in OCaml.</p>
<p>We can take the <code>ListF</code> module defined above and extend it into an applicative.
In fact, it&rsquo;s kind of the other way around: <code>ListA</code> re-exports the
implementation of <code>ListF</code> for the functorial part of the signature.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">ListA</span><span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">APPLICATIVE</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#66d9ef">list</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">include</span> <span style="color:#a6e22e">ListF</span>

  <span style="color:#75715e">(** Put a value in a list *)</span>
  <span style="color:#66d9ef">let</span> pure x <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>x<span style="color:#f92672">]</span>

  <span style="color:#75715e">(** Take a list of functions and a list of values,
</span><span style="color:#75715e">    *  and applies each function to each element of the
</span><span style="color:#75715e">    *  list -- in practice, is a cartesian product *)</span>
  <span style="color:#66d9ef">let</span> ap fs xs <span style="color:#f92672">=</span>
    fmap <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> f <span style="color:#f92672">-&gt;</span> fmap <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> x <span style="color:#f92672">-&gt;</span> f x<span style="color:#f92672">)</span> xs<span style="color:#f92672">)</span> fs
    <span style="color:#f92672">|&gt;</span> List.concat
<span style="color:#66d9ef">end</span>
</code></pre></div><p>Another immediate example is <code>option</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">OptionA</span><span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">APPLICATIVE</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>a option<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">include</span> <span style="color:#a6e22e">OptionF</span>

  <span style="color:#75715e">(** Put a value in a Optional *)</span>
  <span style="color:#66d9ef">let</span> pure x <span style="color:#f92672">=</span> <span style="color:#a6e22e">Some</span> x

  <span style="color:#75715e">(** Take a option function and a option value,
</span><span style="color:#75715e">    * and applies the function to the value if
</span><span style="color:#75715e">    * they both exists *)</span>
  <span style="color:#66d9ef">let</span> ap f x <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> f<span style="color:#f92672">,</span> x <span style="color:#66d9ef">with</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Some</span> f<span style="color:#f92672">,</span> <span style="color:#a6e22e">Some</span> x <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Some</span> <span style="color:#f92672">(</span>f x<span style="color:#f92672">)</span>
    <span style="color:#f92672">|</span> <span style="color:#f92672">_</span>              <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">None</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>We can also define an applicative for the <code>result</code> type.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">ResultA</span><span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">APPLICATIVE</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> <span style="color:#66d9ef">string</span><span style="color:#f92672">)</span> result<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">include</span> <span style="color:#a6e22e">ResultF</span>

  <span style="color:#75715e">(** Put a value in a Result *)</span>
  <span style="color:#66d9ef">let</span> pure x <span style="color:#f92672">=</span> <span style="color:#a6e22e">Ok</span> x

  <span style="color:#75715e">(** Take a result function and a result value,
</span><span style="color:#75715e">    * and applies the function to the value if
</span><span style="color:#75715e">    * they both exists *)</span>
  <span style="color:#66d9ef">let</span> ap f x <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> f<span style="color:#f92672">,</span> x <span style="color:#66d9ef">with</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Ok</span> f<span style="color:#f92672">,</span> <span style="color:#a6e22e">Ok</span> x       <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Ok</span> <span style="color:#f92672">(</span>f x<span style="color:#f92672">)</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Error</span> e<span style="color:#f92672">,</span> <span style="color:#a6e22e">Ok</span> <span style="color:#f92672">_</span>    <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Error</span> e
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Ok</span> <span style="color:#f92672">_,</span> <span style="color:#a6e22e">Error</span> e    <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Error</span> e
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Error</span> e<span style="color:#f92672">,</span> <span style="color:#a6e22e">Error</span> f <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Error</span> <span style="color:#f92672">(</span>String.concat <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">[</span>e<span style="color:#f92672">;</span> f<span style="color:#f92672">])</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>Note here that we can replace the string with <em>any monoidal type</em>, and the last
line of <code>ap</code> would just be changed into <code>| Error e, Error f -&gt; Error (e &lt;&gt; f)</code>.</p>
<p>Note also that the applicatives are always &ldquo;short circuiting&rdquo;, <code>ap</code> necessarily
does the following: if everything can be extracted, proceed, otherwise always
fall back to the &ldquo;failure&rdquo; case.</p>
<p>In <a href="http://blog.shaynefletcher.org/2017/05/more-type-classes-in-ocaml.html" title="More type classes in OCaml">more-typeclasses</a> there is an interesting derivation using the identity
applicative: it&rsquo;s worth having a look at that post. The identity applicative is
simply:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a id <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>a

<span style="color:#66d9ef">module</span> <span style="color:#a6e22e">IdApp</span><span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">APPLICATIVE</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>a id<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t  <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>a id
  <span style="color:#66d9ef">let</span> pure x <span style="color:#f92672">=</span> x
  <span style="color:#66d9ef">let</span> fmap f <span style="color:#f92672">=</span> f
  <span style="color:#66d9ef">let</span> ap     <span style="color:#f92672">=</span> fmap
<span style="color:#66d9ef">end</span>
</code></pre></div><p>What can we do with applicatives? Whay do we care? Let&rsquo;s see an example use to
mock data to test some <a href="http://xapi-project.github.io" title="Xapi project">xapi</a> functionality. Given the following types and helpers</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">type</span> vm_type          <span style="color:#f92672">=</span> <span style="color:#a6e22e">PV</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">HVM</span>
<span style="color:#66d9ef">type</span> storage_location <span style="color:#f92672">=</span> <span style="color:#a6e22e">Local</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">NFS</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">SCSI</span>
<span style="color:#66d9ef">type</span> vgpu_type        <span style="color:#f92672">=</span> <span style="color:#a6e22e">None</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">AMD</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Nvidia</span>

<span style="color:#66d9ef">type</span> vm <span style="color:#f92672">=</span>
  <span style="color:#f92672">{</span> storage_size<span style="color:#f92672">:</span> <span style="color:#66d9ef">int</span>
  <span style="color:#f92672">;</span> storage_location<span style="color:#f92672">:</span> storage_location
  <span style="color:#f92672">;</span> vgpu_type<span style="color:#f92672">:</span> vgpu_type
  <span style="color:#f92672">;</span> vm_type<span style="color:#f92672">:</span> vm_type
  <span style="color:#f92672">}</span>

<span style="color:#66d9ef">let</span> vm_of storage_size storage_location vgpu_type vm_type <span style="color:#f92672">=</span>
  <span style="color:#f92672">{</span> storage_size
  <span style="color:#f92672">;</span> storage_location
  <span style="color:#f92672">;</span> vgpu_type
  <span style="color:#f92672">;</span> vm_type
  <span style="color:#f92672">}</span>
</code></pre></div><p>We can generate all the possible configurations in one go by lifting the
constructor and listing the parameter values.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">ListApp</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Applicative_Utils</span><span style="color:#f92672">(</span><span style="color:#a6e22e">ListA</span><span style="color:#f92672">)</span>

<span style="color:#66d9ef">let</span> vm_templates <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">ListApp</span> <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">FunU</span> <span style="color:#66d9ef">in</span>    <span style="color:#75715e">(* &lt;- unneeded if we use module signatures properly *)</span>
  vm_of
  <span style="color:#f92672">&lt;$&gt;</span> <span style="color:#f92672">[</span>1000000<span style="color:#f92672">;</span> 10000000<span style="color:#f92672">;</span> 10000000<span style="color:#f92672">;</span> 1234567890123456<span style="color:#f92672">]</span>
  <span style="color:#f92672">&lt;*&gt;</span> <span style="color:#f92672">[</span><span style="color:#a6e22e">Local</span><span style="color:#f92672">;</span> <span style="color:#a6e22e">NFS</span><span style="color:#f92672">;</span> <span style="color:#a6e22e">SCSI</span><span style="color:#f92672">]</span>
  <span style="color:#f92672">&lt;*&gt;</span> <span style="color:#f92672">[</span><span style="color:#a6e22e">None</span><span style="color:#f92672">;</span> <span style="color:#a6e22e">AMD</span><span style="color:#f92672">;</span> <span style="color:#a6e22e">Nvidia</span><span style="color:#f92672">]</span>
  <span style="color:#f92672">&lt;*&gt;</span> <span style="color:#f92672">[</span><span style="color:#a6e22e">PV</span><span style="color:#f92672">;</span> <span style="color:#a6e22e">HVM</span><span style="color:#f92672">]</span>

<span style="color:#75715e">(*
</span><span style="color:#75715e"># List.length vm_templates
</span><span style="color:#75715e">- : int = 72
</span><span style="color:#75715e">*)</span>
</code></pre></div><p>We can use <code>OptionalA</code> to generate functions that accept <code>optional</code> arguments on
demand. E.g. safe mathematical functions, or list head and tail. This could have
prevented issues like the division by zero in the intel vgpu configuration in
xapi.</p>
<p>You can find plenty of examples of applicative instances at
<a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Applicative.html" title="Control.Applicative on Hackage">hackage-control.applicative</a>.</p>
<h2 id="small-monadic-intermission">Small monadic intermission</h2>
<p>We will not say much about monads in this brief notes, although they perfectly
fit the final examples. But a digression here to plant a seed is in order.</p>
<p>We saw that every <code>Applicative</code> is a <code>Functor</code>. Every <code>Monad</code> is an
<code>Applicative</code>. The defition turns out to be the following (bear in mind that
there are laws that should be satisfied by these functions. We will not discuss
them here)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MONAD</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">sig</span>
  <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t
  <span style="color:#66d9ef">include</span> <span style="color:#a6e22e">APPLICATIVE</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">:=</span> <span style="color:#66d9ef">&#39;</span>a t

  <span style="color:#75715e">(** Lift a value *)</span>
  <span style="color:#75715e">(* this already resembles [pure] from APPLICATIVE *)</span>
  <span style="color:#66d9ef">val</span> return<span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t
  <span style="color:#75715e">(** &#39;Kind of&#39; sequential application, called `bind` *)</span>
  <span style="color:#66d9ef">val</span> <span style="color:#f92672">(&gt;&gt;=):</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t
<span style="color:#66d9ef">end</span>
</code></pre></div><p>Before going on, keep in mind that there is a standard function named <code>(=&lt;&lt;)</code>
which is exactly <code>(&gt;&gt;=)</code>, but with its arguments flipped.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">val</span> <span style="color:#f92672">(&gt;&gt;=):</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t<span style="color:#f92672">)</span>         <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t
<span style="color:#66d9ef">val</span> <span style="color:#f92672">(=&lt;&lt;):</span>         <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t
</code></pre></div><p>If we look at the structures that we have mentioned so far, we can see that they
all give us a way to apply functions.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">val</span> <span style="color:#f92672">(@@):</span>  <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span>   <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a   <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b     <span style="color:#75715e">(* Function application *)</span>
<span style="color:#66d9ef">val</span> fmap<span style="color:#f92672">:</span>  <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span>   <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t   <span style="color:#75715e">(* Key for Functors *)</span>
<span style="color:#66d9ef">val</span> ap<span style="color:#f92672">:</span>    <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t   <span style="color:#75715e">(* Key for Applicatives *)</span>
<span style="color:#66d9ef">val</span> <span style="color:#f92672">(=&lt;&lt;):</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t   <span style="color:#75715e">(* Key for Monads, you usually see &gt;&gt;= *)</span>
</code></pre></div><p>The major novelty in the bind, compared to the others, is that the function that
it applies is aware of the context (the <code>'a</code> is out of its context and the <code>t</code>
is part of the argument function type signature), and this gives it the power to
modify it and avoid short circuiting!</p>
<p>One last secret is that <code>Monad</code>s are simply a special kind of <code>Applicative</code> for
which we can define a function (<code>join</code>) to collapse the context.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">val</span> join<span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>a t t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t
</code></pre></div><p>When that is defined, the following holds.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> return <span style="color:#f92672">=</span> pure

<span style="color:#75715e">(** Sequentially compose two actions, passing any value produced
</span><span style="color:#75715e"> *  by the first as an argument to the second. *)</span>
<span style="color:#66d9ef">let</span> bind v f <span style="color:#f92672">=</span> join <span style="color:#f92672">(</span>fmap f v<span style="color:#f92672">)</span>
<span style="color:#66d9ef">let</span> <span style="color:#f92672">(&gt;&gt;=)</span> <span style="color:#f92672">=</span> bind

<span style="color:#75715e">(* bind and join are interchangeable: if you have bind defined,
</span><span style="color:#75715e"> * then you can define join as `let join x = x &gt;&gt;= id` *)</span>

<span style="color:#75715e">(* This is a common monad helper *)</span>
<span style="color:#75715e">(** Sequentially compose two actions, discarding any value produced
</span><span style="color:#75715e"> *  by the first, like sequencing operators (such as the semicolon)
</span><span style="color:#75715e"> *  in imperative languages. *)</span>
<span style="color:#66d9ef">let</span> <span style="color:#f92672">(&gt;&gt;)</span>  <span style="color:#f92672">=</span> <span style="color:#f92672">(</span> <span style="color:#f92672">*&gt;</span> <span style="color:#f92672">)</span>
</code></pre></div><p>The difference in the type signatures shows that the Applicative, being context
unaware, can run in parallel and do not rely on previous computations, while the
Monad encodes sequential computations and can make a finer use of the state of
the previous computations. As a friend recently told me, &lsquo;a monad is just a
programmable semicolon&rsquo;.</p>
<p>You can see the incredible amount of helpers for imperative programming that
come as part of monads here: <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad on Hackage">hackage-control.monad</a>.</p>
<h2 id="mixing-things-up-the-alternatives">Mixing things up: the <code>Alternative</code>s</h2>
<p>We have discussed functors and monoids as separate beasts, however there is no
reason for them to be separate&hellip; indeed sometimes we can define a monoid over
the applicative functors: welcome the <code>Alternative</code>s.</p>
<p>For historical reasons, instead of having just a <code>mempty</code> and a <code>mappend</code>, the
alternatives come with their own syntax:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ALTERNATIVE</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">sig</span>
  <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t
  <span style="color:#66d9ef">include</span> <span style="color:#a6e22e">APPLICATIVE</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">:=</span> <span style="color:#66d9ef">&#39;</span>a t

  <span style="color:#75715e">(** The identity of &lt;|&gt; *)</span>
  <span style="color:#66d9ef">val</span> empty<span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>a t
  <span style="color:#75715e">(** An associative binary operation -- practically mappend *)</span>
  <span style="color:#66d9ef">val</span> <span style="color:#f92672">(&lt;|&gt;):</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t
<span style="color:#66d9ef">end</span>
</code></pre></div><p>Being both a monoid and an applicative functor, alternatives come bundled with a
huge set of generic helpers as well.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Alternative_Utils</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">A</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">ALTERNATIVE</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#75715e">(** Generic Alternative helpers *)</span>
  <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">A</span>
  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">AppU</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Applicative_Utils</span><span style="color:#f92672">(</span><span style="color:#a6e22e">A</span><span style="color:#f92672">)</span>
  <span style="color:#66d9ef">include</span> <span style="color:#a6e22e">AppU</span>

  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">AltMonoid</span><span style="color:#f92672">(</span><span style="color:#a6e22e">T</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">GENERIC_TYPE_WORKAROUND</span><span style="color:#f92672">):</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">MONOID</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> T.t A.t<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
    <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> T.t A.t
    <span style="color:#66d9ef">let</span> mempty  <span style="color:#f92672">=</span> A.empty
    <span style="color:#66d9ef">let</span> mappend <span style="color:#f92672">=</span> A.<span style="color:#f92672">(&lt;|&gt;)</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#75715e">(*
</span><span style="color:#75715e">  (* This should not be a comment, but for some reason ocaml 4.03 is optimising
</span><span style="color:#75715e">   * the hell out of it and it ends up in a stack overflow due to infinite recursion.
</span><span style="color:#75715e">   * I have also tried in vane to use lazy, with the same result. They do work, however,
</span><span style="color:#75715e">   * when implemented separately case by case. *)
</span><span style="color:#75715e">
</span><span style="color:#75715e">  (* note the need to break infinite recursion adding an intermediate evaluation *)
</span><span style="color:#75715e">  let delay f = f ()
</span><span style="color:#75715e">
</span><span style="color:#75715e">  (** Zero or more *)
</span><span style="color:#75715e">  (* it could be defined as some v with `in some_ v` replaced by `in many_ v` *)
</span><span style="color:#75715e">  let rec many p = List.cons &lt;$&gt; p &lt;*&gt; (delay @@ fun _ -&gt; many p)
</span><span style="color:#75715e">    &lt;|&gt; pure []
</span><span style="color:#75715e">
</span><span style="color:#75715e">  (** One or more *)
</span><span style="color:#75715e">  let some v = let rec some_ v = cons &lt;$&gt; v &lt;*&gt; (delay @@ fun _ -&gt; many_ v)
</span><span style="color:#75715e">    and many_ v = some_ v &lt;|&gt; pure []
</span><span style="color:#75715e">    in some_ v
</span><span style="color:#75715e">  *)</span>

  <span style="color:#75715e">(** Always return empty *)</span>
  <span style="color:#66d9ef">let</span> fail <span style="color:#f92672">=</span> empty

  <span style="color:#75715e">(** Another name for concat *)</span>
  <span style="color:#66d9ef">let</span> choose <span style="color:#f92672">(</span><span style="color:#66d9ef">type</span> a<span style="color:#f92672">)</span> ps <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">AM</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Monoid_Utils</span><span style="color:#f92672">(</span><span style="color:#a6e22e">AltMonoid</span><span style="color:#f92672">(</span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> a <span style="color:#66d9ef">end</span><span style="color:#f92672">))</span>
    <span style="color:#66d9ef">in</span> AM.concat ps
<span style="color:#66d9ef">end</span>
</code></pre></div><p>The laws that they need to fulfil are both the monoid ones and the functor ones.
I will not enter too much in the detail of alternatives, yet, because an example
will appear soon in the context of the implementation of the parser in the next
session.</p>
<h1 id="a-practical-example---monadic-parsing-library">A practical example - monadic parsing library</h1>
<p>We will try to use the patterns seen above to implement a simple parsing
library, strongly inspired by <a href="http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf" title="Monadic Parser Combinators">hutton</a>.  You can see similar implementations
both in <a href="https://github.com/pyrocat101/opal" title="Self-contained monadic parser combinators for OCaml">opal</a>, <a href="https://github.com/inhabitedtype/angstrom" title="Angstrom: Parser combinators built for speed and memory efficiency">angstrom</a> and <a href="http://blog.shaynefletcher.org/2017/05/more-type-classes-in-ocaml.html" title="More type classes in OCaml">more-typeclasses</a>.  Parser combinators libraries
built from the same ideas are actually used in production, see <a href="https://hackage.haskell.org/package/parsec" title="Haskell's parsec">parsec</a>,
<a href="https://github.com/inhabitedtype/angstrom" title="Angstrom: Parser combinators built for speed and memory efficiency">angstrom</a> and <a href="https://github.com/pcapriotti/optparse-applicative" title="Applicative option parser">optparseapp</a>.</p>
<p>To be fair, some these combinators libraries are based on monadic patterns (see
e.g. the implementation for
<a href="https://github.com/pyrocat101/opal/blob/master/opal.ml">opal</a>) and some on
applicative. Either of them has its pros and its cons, you can see an
interesting comment in <a href="https://stackoverflow.com/questions/7861903/what-are-the-benefits-of-applicative-parsing-over-monadic-parsing#7863380" title="What are the benefits of applicative parsing over monadic parsing?">applicative-or-monadic</a>. The main difference can be
summarised with</p>
<blockquote>
<p>If it helps, you can think of applicative parsers as atomic or parallel while
monadic parsers would be incremental or serial. Yet another way to say it is
that monadic parsers operate on the result of the previous parser and can only
return something to the next; the overall result is then simply the result of
the last parser in the chain. Applicative parsers, on the other hand, operate on
the whole input and contribute directly to the whole output – when combined and
executed, many applicative parsers can run “at once” to produce the final
result.</p>
</blockquote>
<p>The zeroeth step, is to define a type for a parser.  A parser is a function that
takes some test and returns a parsed value and the rest of the text, if any.  We
have tree natural possible types:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">type</span> text <span style="color:#f92672">=</span> <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">list</span>
<span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a p_opt  <span style="color:#f92672">=</span> text <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">*</span> text<span style="color:#f92672">)</span> option
<span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a p_list <span style="color:#f92672">=</span> text <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">*</span> text<span style="color:#f92672">)</span> <span style="color:#66d9ef">list</span>
<span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a p_res  <span style="color:#f92672">=</span> test <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">*</span> text<span style="color:#f92672">)</span> <span style="color:#66d9ef">string</span> result
</code></pre></div><p>We will keep things simple and use the <code>list</code>, to give an implementation
alternative to <a href="http://blog.shaynefletcher.org/2017/05/more-type-classes-in-ocaml.html" title="More type classes in OCaml">more-typeclasses</a> and re-use some of the modules already defined
above.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#75715e">(* this is our parser type *)</span>
<span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a p <span style="color:#f92672">=</span> text <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">*</span> text<span style="color:#f92672">)</span> <span style="color:#66d9ef">list</span>
</code></pre></div><p>Note that <code>text</code> is more general a priori than a list of character, but I&rsquo;ve
chosen this implementation for ease of use. Using some lazy char producer would
have been much more efficient in this case.</p>
<p>We can always convert a string to a list of chars using the following <code>explode</code>
function.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> explode s <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> aux i acc <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> 0 <span style="color:#66d9ef">then</span> acc <span style="color:#66d9ef">else</span> aux <span style="color:#f92672">(</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>s<span style="color:#f92672">.[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">::</span> acc<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
  aux <span style="color:#f92672">(</span>String.length s <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> []
</code></pre></div><p>The simpler parser I can think of matches an empty input and returns something
only in that case.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> empty <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>
  <span style="color:#f92672">|</span> []  <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">[(</span>()<span style="color:#f92672">,</span> []<span style="color:#f92672">)]</span>
  <span style="color:#f92672">|</span> <span style="color:#f92672">_</span>   <span style="color:#f92672">-&gt;</span> []
</code></pre></div><p>Another simple one consumes the first character in <code>text</code> and returns that
character as a result. If it fails it returns the empty list.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> item<span style="color:#f92672">:</span> <span style="color:#66d9ef">char</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>
  <span style="color:#f92672">|</span> []      <span style="color:#f92672">-&gt;</span> []
  <span style="color:#f92672">|</span> c <span style="color:#f92672">::</span> cs <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">[(</span>c<span style="color:#f92672">,</span> cs<span style="color:#f92672">)]</span>
</code></pre></div><p>This can be easily generalised to a parser that given a function, can construct
a new parser that, when successful, consumes a character of the input and
produces a new value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> token f <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>
  <span style="color:#f92672">|</span> []      <span style="color:#f92672">-&gt;</span> []
  <span style="color:#f92672">|</span> c <span style="color:#f92672">::</span> cs <span style="color:#f92672">-&gt;</span> ListF.fmap <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> y <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span>y<span style="color:#f92672">,</span> cs<span style="color:#f92672">))</span> <span style="color:#f92672">(</span>f c<span style="color:#f92672">)</span>
</code></pre></div><p>We can use this to implement a parser to match specific characters.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">char</span> c <span style="color:#f92672">=</span> token <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> c&#39; <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">if</span> c <span style="color:#f92672">=</span> c&#39; <span style="color:#66d9ef">then</span> <span style="color:#f92672">[</span>c<span style="color:#f92672">]</span> <span style="color:#66d9ef">else</span> []<span style="color:#f92672">)</span>
</code></pre></div><p>Given that parsers are functions, the actual <code>parse</code> function does nothing but
applying the parser and extracting the value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> parse parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">fun</span> input <span style="color:#f92672">-&gt;</span>
  <span style="color:#75715e">(* parser input &lt;$&gt; ListF.fmap fst *)</span>
  <span style="color:#66d9ef">match</span> parser input <span style="color:#66d9ef">with</span>
  <span style="color:#f92672">|</span> []  <span style="color:#f92672">-&gt;</span> []
  <span style="color:#f92672">|</span> lst <span style="color:#f92672">-&gt;</span> ListF.fmap fst lst
</code></pre></div><p>Now, if we want to start composing the parsers, chaining many of them or
allowing a choice between multiple ones, we need to find some appropriate
combinators. We have a wrapped type and we know from the previous section that
to apply a function inside wrapped types we can use applicative functors.</p>
<p>We can use the types as a guide to define an applicative functor for parsers.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">ParserApplicative</span><span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">APPLICATIVE</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>a p<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>a p

  <span style="color:#75715e">(* functor *)</span>
  <span style="color:#66d9ef">let</span> fmap f parser <span style="color:#f92672">=</span>
    parser <span style="color:#f92672">&gt;.&gt;</span> ListF.fmap <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> <span style="color:#f92672">(</span>c<span style="color:#f92672">,</span> cs<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span>f c<span style="color:#f92672">,</span> cs<span style="color:#f92672">))</span>

  <span style="color:#75715e">(* applicative *)</span>

  <span style="color:#75715e">(* pure takes a value and wraps it in a parser
</span><span style="color:#75715e">   * -- a function from text to a list of tuples... *)</span>
  <span style="color:#66d9ef">let</span> pure c <span style="color:#f92672">=</span> <span style="color:#66d9ef">fun</span> input <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">[(</span>c<span style="color:#f92672">,</span> input<span style="color:#f92672">)]</span>   <span style="color:#75715e">(* equiv. pure c input = [(c, input)] *)</span>

  <span style="color:#66d9ef">let</span> ap parser_f parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">fun</span> input <span style="color:#f92672">-&gt;</span>
    <span style="color:#66d9ef">match</span> parser_f input <span style="color:#66d9ef">with</span>
    <span style="color:#f92672">|</span> []            <span style="color:#f92672">-&gt;</span> []
    <span style="color:#f92672">|</span> <span style="color:#f92672">(</span>f<span style="color:#f92672">,</span> cs<span style="color:#f92672">)</span> <span style="color:#f92672">::</span> [] <span style="color:#f92672">-&gt;</span> fmap f parser cs
    <span style="color:#f92672">|</span> lst           <span style="color:#f92672">-&gt;</span> List.map <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> <span style="color:#f92672">(</span>f<span style="color:#f92672">,</span> cs<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> fmap f parser cs<span style="color:#f92672">)</span> lst <span style="color:#f92672">|&gt;</span> List.concat <span style="color:#75715e">(* this should not really happen, we could use `-&gt; .` *)</span>
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">module</span> <span style="color:#a6e22e">ParserApp</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Applicative_Utils</span><span style="color:#f92672">(</span><span style="color:#a6e22e">ParserApplicative</span><span style="color:#f92672">)</span>
</code></pre></div><p>Unfortunately parsers are functions, so we cannot really use our test modules
and instead we need to do the math by hand to check the laws.</p>
<p>We can now use <code>pure</code> and <code>ap</code> (or <code>&lt;*&gt;</code>) as building blocks to make the parser
combinators.  For example a parser that parses the input <code>['x';'a';'p';'i']</code> and
produces a unit result:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> xapi <span style="color:#f92672">=</span> <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">ParserApp</span> <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">FunU</span> <span style="color:#66d9ef">in</span>
  <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#34;Gotcha!&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">&lt;$&gt;</span> <span style="color:#66d9ef">char</span> <span style="color:#e6db74">&#39;x&#39;</span> <span style="color:#f92672">&lt;*</span> <span style="color:#66d9ef">char</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#f92672">&lt;*</span> <span style="color:#66d9ef">char</span> <span style="color:#e6db74">&#39;p&#39;</span> <span style="color:#f92672">&lt;*</span> <span style="color:#66d9ef">char</span> <span style="color:#e6db74">&#39;i&#39;</span>
</code></pre></div><p>Running this in <code>utop</code> will show something like the following.</p>
<pre><code># xapi (explode &quot;xapi&quot;);;
- : (string * text) list = [(&quot;Gotcha!&quot;, [])]

# xapi (explode &quot;xapi11&quot;);;
- : (string * text) list = [(&quot;Gotcha!&quot;, ['1'; '1'])]

# xapi (explode &quot;test&quot;);;
- : (string * text) list = []
</code></pre><p>We know more in fact. We can prescribe a parser that always fail and a function
that given two parsers, tries the first and in case of failure tries the second
(something like the <code>Any</code> monoid).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">ParserAlternative</span><span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">ALTERNATIVE</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>a p<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">include</span> <span style="color:#a6e22e">ParserApplicative</span>

  <span style="color:#66d9ef">let</span> empty <span style="color:#f92672">_</span> <span style="color:#f92672">=</span> []

  <span style="color:#66d9ef">let</span> <span style="color:#f92672">(&lt;|&gt;)</span> p1 p2 txt <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">match</span> p1 txt <span style="color:#66d9ef">with</span>
    <span style="color:#f92672">|</span> <span style="color:#f92672">[</span> <span style="color:#f92672">]</span>        <span style="color:#f92672">-&gt;</span> p2 txt
    <span style="color:#f92672">|</span> <span style="color:#f92672">[_]</span> <span style="color:#66d9ef">as</span> res <span style="color:#f92672">-&gt;</span> res
    <span style="color:#f92672">|</span>  <span style="color:#f92672">_</span>  <span style="color:#66d9ef">as</span> res <span style="color:#f92672">-&gt;</span> res  <span style="color:#75715e">(* this will not happen ... we could use `-&gt; .` *)</span>
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">module</span> <span style="color:#a6e22e">ParserAlt</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Alternative_Utils</span><span style="color:#f92672">(</span><span style="color:#a6e22e">ParserAlternative</span><span style="color:#f92672">)</span>
<span style="color:#66d9ef">open</span> <span style="color:#a6e22e">ParserAlt</span>
</code></pre></div><p>The implementation for alternative gives us a <code>choose</code> function to try and apply
multiple parsers, a function <code>some</code> that given a parser either parses one result
of the given parser followed by many results, or in case it fails, consumes no
input and returns an empty list, and a function <code>many</code> that is like <code>some</code> but
does not fail if no result is found.</p>
<p>Another handy combinator is <code>satisfy</code> that takes a predicate function for
<em>filtering</em> a parser by only allowing it to succeed when its result satisfies
the predicate:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> satisfy pred p <span style="color:#f92672">=</span> <span style="color:#66d9ef">fun</span> input <span style="color:#f92672">-&gt;</span>
  <span style="color:#66d9ef">match</span> p input <span style="color:#66d9ef">with</span>
  <span style="color:#f92672">|</span> <span style="color:#f92672">[(</span>x<span style="color:#f92672">,</span> <span style="color:#f92672">_)]</span> <span style="color:#66d9ef">as</span> res <span style="color:#66d9ef">when</span> pred x <span style="color:#f92672">-&gt;</span> res
  <span style="color:#f92672">|</span> <span style="color:#f92672">_</span>                           <span style="color:#f92672">-&gt;</span> []
</code></pre></div><p>Interestingly, the <code>satisfy</code> combinator allows us to define a variation of
<code>some</code>, <code>char</code> and <code>item</code> that is a bit more legible:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> some&#39; pred <span style="color:#f92672">=</span> satisfy <span style="color:#f92672">((&lt;&gt;)</span> []<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>many pred<span style="color:#f92672">)</span>
<span style="color:#66d9ef">let</span> item&#39; <span style="color:#f92672">=</span> satisfy <span style="color:#f92672">(</span>const true<span style="color:#f92672">)</span>
<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">char</span><span style="color:#66d9ef">&#39;</span> c <span style="color:#f92672">=</span> satisfy <span style="color:#f92672">((=)</span> c<span style="color:#f92672">)</span>
</code></pre></div><p>To make things cleaner we can wrap everything in a module with a signature that
hides the implementation details. This also makes the parser type itself
abstract and instead exposes a run function that takes a string as input rather
than a list of characters (as in <a href="https://hackage.haskell.org/package/parsec" title="Haskell's parsec">parsec</a>).</p>
<p>I like the approach used in <a href="http://blog.shaynefletcher.org/2017/05/more-type-classes-in-ocaml.html" title="More type classes in OCaml">more-typeclasses</a> for example. We can use a similar
signature and provide an (almost) swappable implementation</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PARSER</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">sig</span>
  <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t

  <span style="color:#66d9ef">val</span> empty<span style="color:#f92672">:</span>   <span style="color:#66d9ef">unit</span> t
  <span style="color:#66d9ef">val</span> run<span style="color:#f92672">:</span>     <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#66d9ef">list</span>
  <span style="color:#66d9ef">val</span> map<span style="color:#f92672">:</span>     <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t
  <span style="color:#66d9ef">val</span> pure<span style="color:#f92672">:</span>    <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t
  <span style="color:#66d9ef">val</span> ap<span style="color:#f92672">:</span>      <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t
  <span style="color:#66d9ef">val</span> <span style="color:#f92672">(</span> <span style="color:#f92672">&lt;$&gt;</span> <span style="color:#f92672">):</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t
  <span style="color:#66d9ef">val</span> <span style="color:#f92672">(</span> <span style="color:#f92672">&lt;*&gt;</span> <span style="color:#f92672">):</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t
  <span style="color:#66d9ef">val</span> <span style="color:#f92672">(</span> <span style="color:#f92672">&lt;*</span>  <span style="color:#f92672">):</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t
  <span style="color:#66d9ef">val</span> <span style="color:#f92672">(</span> <span style="color:#f92672">*&gt;</span>  <span style="color:#f92672">):</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b t
  <span style="color:#66d9ef">val</span> token<span style="color:#f92672">:</span>   <span style="color:#f92672">(</span><span style="color:#66d9ef">char</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#66d9ef">list</span><span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t
  <span style="color:#66d9ef">val</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">:</span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">char</span> t
  <span style="color:#66d9ef">val</span> fail<span style="color:#f92672">:</span>    <span style="color:#66d9ef">&#39;</span>a t
  <span style="color:#66d9ef">val</span> choose<span style="color:#f92672">:</span>  <span style="color:#66d9ef">&#39;</span>a t <span style="color:#66d9ef">list</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t
  <span style="color:#66d9ef">val</span> <span style="color:#f92672">(</span> <span style="color:#f92672">&lt;|&gt;</span> <span style="color:#f92672">):</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t
  <span style="color:#66d9ef">val</span> many<span style="color:#f92672">:</span>    <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#66d9ef">list</span> t
  <span style="color:#66d9ef">val</span> some<span style="color:#f92672">:</span>    <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#66d9ef">list</span> t
  <span style="color:#66d9ef">val</span> filter<span style="color:#f92672">:</span>  <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span><span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">CHARPARSER</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">functor</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">P</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">PARSER</span><span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">sig</span>

  <span style="color:#75715e">(* Some optional helpers *)</span>
  <span style="color:#66d9ef">val</span> exactly<span style="color:#f92672">:</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">char</span> P.t
  <span style="color:#66d9ef">val</span> one_of<span style="color:#f92672">:</span>  <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">list</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">char</span> P.t
  <span style="color:#66d9ef">val</span> none_of<span style="color:#f92672">:</span> <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">list</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">char</span> P.t
  <span style="color:#66d9ef">val</span> range<span style="color:#f92672">:</span>   <span style="color:#66d9ef">char</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">char</span> P.t
  <span style="color:#66d9ef">val</span> space<span style="color:#f92672">:</span>   <span style="color:#66d9ef">char</span> P.t
  <span style="color:#66d9ef">val</span> newline<span style="color:#f92672">:</span> <span style="color:#66d9ef">char</span> P.t
  <span style="color:#66d9ef">val</span> tab<span style="color:#f92672">:</span>     <span style="color:#66d9ef">char</span> P.t
  <span style="color:#66d9ef">val</span> upper<span style="color:#f92672">:</span>   <span style="color:#66d9ef">char</span> P.t
  <span style="color:#66d9ef">val</span> lower<span style="color:#f92672">:</span>   <span style="color:#66d9ef">char</span> P.t
  <span style="color:#66d9ef">val</span> digit<span style="color:#f92672">:</span>   <span style="color:#66d9ef">char</span> P.t
  <span style="color:#66d9ef">val</span> letter<span style="color:#f92672">:</span>  <span style="color:#66d9ef">char</span> P.t
  <span style="color:#66d9ef">val</span> alpha_num<span style="color:#f92672">:</span> <span style="color:#66d9ef">char</span> P.t
  <span style="color:#66d9ef">val</span> hex_digit<span style="color:#f92672">:</span> <span style="color:#66d9ef">char</span> P.t
  <span style="color:#66d9ef">val</span> oct_digit<span style="color:#f92672">:</span> <span style="color:#66d9ef">char</span> P.t
<span style="color:#66d9ef">end</span>
</code></pre></div><p>You can see that introducing the alternatives, reduces even more the amount of
special combinators needed to define the parser itself (compare this with the
one obtained in <a href="http://blog.shaynefletcher.org/2017/05/more-type-classes-in-ocaml.html" title="More type classes in OCaml">more-typeclasses</a>)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Parser</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">PARSER</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">include</span> <span style="color:#a6e22e">ParserAlternative</span>
  <span style="color:#66d9ef">include</span> <span style="color:#a6e22e">ParserAlt</span>

  <span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> fmap

  <span style="color:#66d9ef">let</span> explode s <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> aux i acc <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> 0 <span style="color:#66d9ef">then</span> acc <span style="color:#66d9ef">else</span> aux <span style="color:#f92672">(</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>s<span style="color:#f92672">.[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">::</span> acc<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
    aux <span style="color:#f92672">(</span>String.length s <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> []

  <span style="color:#66d9ef">let</span> run p s <span style="color:#f92672">=</span> explode s
    <span style="color:#f92672">|&gt;</span> p
    <span style="color:#f92672">|&gt;</span> ListF.fmap fst

  <span style="color:#66d9ef">let</span> empty <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>
    <span style="color:#f92672">|</span> []  <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">[(</span>()<span style="color:#f92672">,</span> []<span style="color:#f92672">)]</span>
    <span style="color:#f92672">|</span> <span style="color:#f92672">_</span>   <span style="color:#f92672">-&gt;</span> []

  <span style="color:#66d9ef">let</span> token f <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>
    <span style="color:#f92672">|</span> []      <span style="color:#f92672">-&gt;</span> []
    <span style="color:#f92672">|</span> x <span style="color:#f92672">::</span> xs <span style="color:#f92672">-&gt;</span> ListF.fmap <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> y <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span>y<span style="color:#f92672">,</span> xs<span style="color:#f92672">))</span> <span style="color:#f92672">(</span>f x<span style="color:#f92672">)</span>

  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">char</span> c <span style="color:#f92672">=</span> token <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> c&#39; <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">if</span> c <span style="color:#f92672">=</span> c&#39; <span style="color:#66d9ef">then</span> <span style="color:#f92672">[</span>c<span style="color:#f92672">]</span> <span style="color:#66d9ef">else</span> []<span style="color:#f92672">)</span>

  <span style="color:#66d9ef">let</span> satisfy f p cs <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">match</span> p cs <span style="color:#66d9ef">with</span>
    <span style="color:#f92672">|</span> <span style="color:#f92672">[(</span>x<span style="color:#f92672">,</span> cs<span style="color:#f92672">)]</span> <span style="color:#66d9ef">when</span> f x <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">[(</span>x<span style="color:#f92672">,</span>cs<span style="color:#f92672">)]</span>
    <span style="color:#f92672">|</span> <span style="color:#f92672">_</span>                  <span style="color:#f92672">-&gt;</span> []

  <span style="color:#66d9ef">let</span> filter <span style="color:#f92672">=</span> satisfy

  <span style="color:#66d9ef">let</span> delay f xs <span style="color:#f92672">=</span> f () xs

  <span style="color:#75715e">(* These are alternative&#39;s helpers, but we needed to move them
</span><span style="color:#75715e">   * here to avoid infinite recursion... To be investigated... *)</span>
  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> many p <span style="color:#f92672">=</span> List.cons <span style="color:#f92672">&lt;$&gt;</span> p <span style="color:#f92672">&lt;*&gt;</span> <span style="color:#f92672">(</span>delay <span style="color:#f92672">@@</span> <span style="color:#66d9ef">fun</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> many p<span style="color:#f92672">)</span>
    <span style="color:#f92672">&lt;|&gt;</span> pure []
  <span style="color:#66d9ef">let</span> some p <span style="color:#f92672">=</span> satisfy <span style="color:#f92672">((&lt;&gt;)</span> []<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>many p<span style="color:#f92672">)</span>
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">module</span> <span style="color:#a6e22e">MakeCharParser</span><span style="color:#f92672">(</span><span style="color:#a6e22e">P</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">PARSER</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">P</span>

  <span style="color:#66d9ef">let</span> item <span style="color:#f92672">=</span> token <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> c <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">[</span>c<span style="color:#f92672">])</span>

  <span style="color:#66d9ef">let</span> exactly x <span style="color:#f92672">=</span> filter <span style="color:#f92672">((=)</span> x<span style="color:#f92672">)</span> item
  <span style="color:#66d9ef">let</span> one_of  l <span style="color:#f92672">=</span> filter <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> x <span style="color:#f92672">-&gt;</span> List.mem x l<span style="color:#f92672">)</span> item
  <span style="color:#66d9ef">let</span> none_of l <span style="color:#f92672">=</span> filter <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> x <span style="color:#f92672">-&gt;</span> not <span style="color:#f92672">(</span>List.mem x l<span style="color:#f92672">))</span> item
  <span style="color:#66d9ef">let</span> range l r <span style="color:#f92672">=</span> filter <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> x <span style="color:#f92672">-&gt;</span> l <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;=</span> r<span style="color:#f92672">)</span> item

  <span style="color:#66d9ef">let</span> space     <span style="color:#f92672">=</span> one_of <span style="color:#f92672">[</span><span style="color:#e6db74">&#39; &#39;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#39;\t&#39;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#39;\r&#39;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#39;\n&#39;</span><span style="color:#f92672">]</span>
  <span style="color:#66d9ef">let</span> newline   <span style="color:#f92672">=</span> exactly <span style="color:#e6db74">&#39;\n&#39;</span>
  <span style="color:#66d9ef">let</span> tab       <span style="color:#f92672">=</span> exactly <span style="color:#e6db74">&#39;\t&#39;</span>
  <span style="color:#66d9ef">let</span> upper     <span style="color:#f92672">=</span> range <span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#e6db74">&#39;Z&#39;</span>
  <span style="color:#66d9ef">let</span> lower     <span style="color:#f92672">=</span> range <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#e6db74">&#39;z&#39;</span>
  <span style="color:#66d9ef">let</span> digit     <span style="color:#f92672">=</span> range <span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#e6db74">&#39;9&#39;</span>
  <span style="color:#66d9ef">let</span> letter    <span style="color:#f92672">=</span> lower  <span style="color:#f92672">&lt;|&gt;</span> upper
  <span style="color:#66d9ef">let</span> alpha_num <span style="color:#f92672">=</span> letter <span style="color:#f92672">&lt;|&gt;</span> digit
  <span style="color:#66d9ef">let</span> hex_digit <span style="color:#f92672">=</span> range <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#e6db74">&#39;f&#39;</span> <span style="color:#f92672">&lt;|&gt;</span> range <span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#e6db74">&#39;F&#39;</span> <span style="color:#f92672">&lt;|&gt;</span> digit
  <span style="color:#66d9ef">let</span> oct_digit <span style="color:#f92672">=</span> range <span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#e6db74">&#39;7&#39;</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>This is the same as the example in <a href="http://blog.shaynefletcher.org/2017/05/more-type-classes-in-ocaml.html" title="More type classes in OCaml">more-typeclasses</a>. Consider a parser for
parsing dates of the format <code>YYYY-MM-DD</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">CP</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">MakeCharParser</span><span style="color:#f92672">(</span><span style="color:#a6e22e">Parser</span><span style="color:#f92672">)</span>
<span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Parser</span>
<span style="color:#66d9ef">open</span> <span style="color:#a6e22e">CP</span>

<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> string_of_list <span style="color:#f92672">=</span> List.map <span style="color:#f92672">(</span>String.make 1<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;.&gt;</span> String.concat <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#66d9ef">in</span>
  <span style="color:#f92672">(</span>string_of_list <span style="color:#f92672">&gt;.&gt;</span> int_of_string<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;$&gt;</span> some digit

<span style="color:#66d9ef">let</span> int_range mn mx <span style="color:#f92672">=</span> filter <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> n <span style="color:#f92672">-&gt;</span> mn <span style="color:#f92672">&lt;=</span> n <span style="color:#f92672">&amp;&amp;</span> n <span style="color:#f92672">&lt;=</span> mx<span style="color:#f92672">)</span> <span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">let</span> zero_digit <span style="color:#f92672">=</span> <span style="color:#66d9ef">char</span> <span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">*&gt;</span> int_range 1 9
<span style="color:#66d9ef">let</span> year  <span style="color:#f92672">=</span> int_range 1700 2400
<span style="color:#66d9ef">let</span> month <span style="color:#f92672">=</span> zero_digit <span style="color:#f92672">&lt;|&gt;</span> int_range 10 12
<span style="color:#66d9ef">let</span> day <span style="color:#f92672">=</span> zero_digit <span style="color:#f92672">&lt;|&gt;</span> int_range 10 31

<span style="color:#66d9ef">let</span> date <span style="color:#f92672">=</span>
  <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> y m d <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span>y<span style="color:#f92672">,</span>m<span style="color:#f92672">,</span>d<span style="color:#f92672">))</span>
  <span style="color:#f92672">&lt;$&gt;</span> <span style="color:#f92672">(</span>year <span style="color:#f92672">&lt;*</span> <span style="color:#66d9ef">char</span> <span style="color:#e6db74">&#39;-&#39;</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">&lt;*&gt;</span> <span style="color:#f92672">(</span>month <span style="color:#f92672">&lt;*</span> <span style="color:#66d9ef">char</span> <span style="color:#e6db74">&#39;-&#39;</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">&lt;*&gt;</span> day
</code></pre></div><p>Here are a few examples of running the <code>date</code> parser with different string
inputs:</p>
<pre><code># run date &quot;2019-01-23&quot;;;
- : (int * int * int) list = [(2019, 1, 23)]

# run date &quot;2019-10-23&quot;;;
- : (int * int * int) list = [(2019, 10, 23)]

# run date &quot;2019-1-23&quot;;;
- : (int * int * int) list = []

# run date &quot;999-1-23&quot;;;
- : (int * int * int) list = []

# run date &quot;a999-1-23&quot;;;
- : (int * int * int) list = []
</code></pre><p>We did not mention it later&hellip; but to match exactly <code>xapi</code> we can use the
<code>empty</code> parser:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> xapi <span style="color:#f92672">=</span> <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Parser</span> <span style="color:#66d9ef">in</span>
  <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#34;Gotcha!&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">&lt;$&gt;</span> exactly <span style="color:#e6db74">&#39;x&#39;</span> <span style="color:#f92672">&lt;*</span> exactly <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#f92672">&lt;*</span> exactly <span style="color:#e6db74">&#39;p&#39;</span> <span style="color:#f92672">&lt;*</span> exactly <span style="color:#e6db74">&#39;i&#39;</span> <span style="color:#f92672">&lt;*</span> empty
</code></pre></div><p>That in <code>utop</code> gives</p>
<pre><code># run xapi &quot;xapi&quot;
- : string list [&quot;Gotcha!&quot;]

# run xapi &quot;xapi1&quot;
- : string list []
</code></pre><p>Another interesting example could be a parser that counts the longest
parenthesis nesting in a parenthesis only string:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PARENS</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">sig</span>
  <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a t
  <span style="color:#66d9ef">val</span> run<span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#66d9ef">list</span>
  <span style="color:#66d9ef">val</span> parens<span style="color:#f92672">:</span> <span style="color:#66d9ef">int</span> t
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Parens</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">PARENS</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
  <span style="color:#66d9ef">include</span> <span style="color:#a6e22e">ParserAlternative</span>
  <span style="color:#66d9ef">include</span> <span style="color:#a6e22e">ParserAlt</span>

  <span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> fmap

  <span style="color:#66d9ef">let</span> explode s <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> aux i acc <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> 0 <span style="color:#66d9ef">then</span> acc <span style="color:#66d9ef">else</span> aux <span style="color:#f92672">(</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>s<span style="color:#f92672">.[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">::</span> acc<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
    aux <span style="color:#f92672">(</span>String.length s <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> []

  <span style="color:#66d9ef">let</span> run p s <span style="color:#f92672">=</span> explode s
    <span style="color:#f92672">|&gt;</span> p
    <span style="color:#f92672">|&gt;</span> ListF.fmap fst

  <span style="color:#66d9ef">let</span> token f <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>
    <span style="color:#f92672">|</span> []      <span style="color:#f92672">-&gt;</span> []
    <span style="color:#f92672">|</span> x <span style="color:#f92672">::</span> xs <span style="color:#f92672">-&gt;</span> ListF.fmap <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> y <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span>y<span style="color:#f92672">,</span> xs<span style="color:#f92672">))</span> <span style="color:#f92672">(</span>f x<span style="color:#f92672">)</span>

  <span style="color:#66d9ef">let</span> satisfy f p cs <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">match</span> p cs <span style="color:#66d9ef">with</span>
    <span style="color:#f92672">|</span> <span style="color:#f92672">[(</span>x<span style="color:#f92672">,</span> cs<span style="color:#f92672">)]</span> <span style="color:#66d9ef">when</span> f x <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">[(</span>x<span style="color:#f92672">,</span>cs<span style="color:#f92672">)]</span>
    <span style="color:#f92672">|</span> <span style="color:#f92672">_</span>                  <span style="color:#f92672">-&gt;</span> []

  <span style="color:#66d9ef">let</span> item <span style="color:#f92672">=</span> token <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> c <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">[</span>c<span style="color:#f92672">])</span>
  <span style="color:#66d9ef">let</span> exactly x <span style="color:#f92672">=</span> satisfy <span style="color:#f92672">((=)</span> x<span style="color:#f92672">)</span> item

  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> parens txt <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>
    <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> <span style="color:#f92672">_</span> b <span style="color:#f92672">_</span> d <span style="color:#f92672">-&gt;</span> max <span style="color:#f92672">(</span>1<span style="color:#f92672">+</span>b<span style="color:#f92672">)</span> d<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;$&gt;</span> exactly <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#f92672">&lt;*&gt;</span> parens <span style="color:#f92672">&lt;*&gt;</span> exactly <span style="color:#e6db74">&#39;)&#39;</span> <span style="color:#f92672">&lt;*&gt;</span> parens
    <span style="color:#f92672">&lt;|&gt;</span> pure 0
  <span style="color:#f92672">)</span> txt
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Parens</span>
</code></pre></div><p>That in <code>utop</code> gives</p>
<pre><code># open Parens

# run parens &quot;(())&quot;
- : int list = [2]

# run parens &quot;1(())&quot;)
- : int list = [0]

# run parens &quot;(()()()())&quot;
- : int list = [2]

# run parens &quot;((()())()()())&quot;
- : int list = [3]

# run parens &quot;((()(()))()()())&quot;
- : int list = [4]

# run parens &quot;((()(()))()()(()()((((((()))))))))&quot;
- : int list = [9]
</code></pre>
    </div>
    <div class="post-footer">
      <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    this.page.identifier = '43';
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "talesofafractalspectrum" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </article>

    </main>
  </body>
</html>
